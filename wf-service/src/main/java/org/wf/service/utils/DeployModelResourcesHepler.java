package org.wf.service.utils;

import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.List;

import javax.annotation.Resource;

import org.activiti.engine.ActivitiObjectNotFoundException;
import org.activiti.engine.RepositoryService;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.DeploymentQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.stereotype.Component;


/**
 * a tool to automatically deploy process definitions, checking the SHA-1 value between bpmn file modifications.
 * @author zhurunjia
 *
 */
@Component("deployModelResourcesHepler")
public class DeployModelResourcesHepler implements InitializingBean {
	
	private final static Logger logger = LoggerFactory.getLogger(DeployModelResourcesHepler.class);
	
	@Resource(name = "repositoryService")
	private RepositoryService repositoryService;
	
	private String loadResourcesPattern = "deployments/*.bpmn";
	
	private final static String messageDigestAlgorithm = "SHA-1";

	@Override
	public void afterPropertiesSet() throws Exception {
		DeploymentQuery dQuery = repositoryService.createDeploymentQuery();
		
		// list all resources under specified resourceDir
		// consider only .bpmn files
		ResourcePatternResolver rpr = new PathMatchingResourcePatternResolver();
		org.springframework.core.io.Resource[] rArray = rpr.getResources(loadResourcesPattern);
		
		for(org.springframework.core.io.Resource resource : rArray) {
			InputStream ins = null;
			try {
				ins = resource.getInputStream();
				// compute the SHA-1 value
				byte[] currentMdBytes = getMessageDigest(ins);
				boolean needDeploy = false;
				
				String resourceName = resource.getURL().getPath();
				String deploymentName = resource.getFilename();
				// find the latest deployment for this
				List<Deployment> historyDeployList = dQuery.deploymentName(deploymentName)
									.orderByDeploymenTime().desc().list();
				if (historyDeployList == null || historyDeployList.size() == 0) {
					// no deployment in history
					needDeploy = true;
					
				} else {
					Deployment d = historyDeployList.get(0);
					try {
						// the stream comes from built-in act_ge_bytearray(BYTES_ longblob) table
						InputStream previousIns = repositoryService.getResourceAsStream(d.getId(), resourceName);
						// compute the MessageDigest
						byte[] previousMdBytes = getMessageDigest(previousIns);
					
						if( ! compareMessageDigestBytes(currentMdBytes, previousMdBytes)) {
							// not equal, which means there is bpmn modificaitons
							needDeploy = true;
						}
					} catch (ActivitiObjectNotFoundException ae){
						// resource is not present
						needDeploy = true;
					}
				}
				
				if (needDeploy) {
					logger.info("need to deploy resource for " + resource.getFilename());
					repositoryService.createDeployment().name(deploymentName).addInputStream(
							resourceName, resource.getInputStream()).deploy();
				} else {
					logger.info("no modifications for deploymentName: " + deploymentName);
				}
			} catch(Exception e) {
				logger.error("deploy resource fails for " + resource.getFilename() + ","
									+ (e != null ? e.getMessage() : "") );
			}
			
		}
	}
	
	/**
	 * true if the two messageDigest bytes are equal, otherwise false.
	 */
	private boolean compareMessageDigestBytes(byte[] r1, byte[] r2) {
		if( r1 == null || r2 == null)
			return false;
		
		logger.info("comparing two messageDigest bytes: " + Arrays.toString(r1) + ", " + Arrays.toString(r2));
		int i = 0;
		// assume r1 and r2 is the same length, since they are generated by the same messageDigest algorithm
		while (i < r1.length) {
			if (r1[i] != r2[i]) {
				return false;
			}
			i++;
		}
		return true;
	}
	
	/**
	 * get message  digest bytes, and close the inputStream
	 * @param ins
	 * @return
	 */
	private byte[] getMessageDigest(InputStream ins)  {
		try {
			MessageDigest md = MessageDigest.getInstance(messageDigestAlgorithm);
			byte[] buffer = new byte[1 << 9];
			int reads = -1;
			while ( (reads = ins.read(buffer)) != -1 ){
				md.update(buffer, 0, reads);
			}
			byte[] mdBytes = md.digest();
			return mdBytes;
			
		} catch(Exception e) {
			throw new RuntimeException("getMessageDigest error, " + (e != null ? e.getMessage() : ""));
		} finally {
			if( ins != null) {
				try {
					ins.close();
				} catch (IOException e) { }
			}
		}
	}

}
